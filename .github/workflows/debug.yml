name: debug build

on:
  push:
    branches:
      - cicd

env:
  DOCKER_INTERMEDIATE_REPO: "nwodtuhs/exegol-builds"
  DOCKER_PROD_REPO: "nwodtuhs/exegol-dev"
  IMAGE_BASE_NAME: "debug"
  DOCKERFILE: "./debug.dockerfile"

jobs:
  amd64_buildx:
    timeout-minutes: 360
    runs-on: [ self-hosted, test ]
    outputs:
      matrix_p1: ${{ steps.set-matrix.outputs.matrix_p1 }}
      matrix_p2: ${{ steps.set-matrix.outputs.matrix_p2 }}
      matrix_p3: ${{ steps.set-matrix.outputs.matrix_p3 }}
      matrix_p4: ${{ steps.set-matrix.outputs.matrix_p4 }}
      matrix_osint: ${{ steps.set-matrix.outputs.matrix_osint }}
      matrix_web: ${{ steps.set-matrix.outputs.matrix_web }}
      matrix_c2: ${{ steps.set-matrix.outputs.matrix_c2 }}
      matrix_ad: ${{ steps.set-matrix.outputs.matrix_ad }}
      matrix_mobile: ${{ steps.set-matrix.outputs.matrix_mobile }}
      matrix_iot: ${{ steps.set-matrix.outputs.matrix_iot }}
      matrix_rfid: ${{ steps.set-matrix.outputs.matrix_rfid }}
      matrix_voip: ${{ steps.set-matrix.outputs.matrix_voip }}
      matrix_sdr: ${{ steps.set-matrix.outputs.matrix_sdr }}
      matrix_network: ${{ steps.set-matrix.outputs.matrix_network }}
      matrix_wifi: ${{ steps.set-matrix.outputs.matrix_wifi }}
      matrix_forensic: ${{ steps.set-matrix.outputs.matrix_forensic }}
      matrix_cloud: ${{ steps.set-matrix.outputs.matrix_cloud }}
      matrix_steganography: ${{ steps.set-matrix.outputs.matrix_steganography }}
      matrix_reverse: ${{ steps.set-matrix.outputs.matrix_reverse }}
      matrix_crypto: ${{ steps.set-matrix.outputs.matrix_crypto }}
      matrix_code_analysis: ${{ steps.set-matrix.outputs.matrix_code_analysis }}
    steps:
      - name: Checkout
        uses: actions/checkout@v3
      - name: Prepare build
        id: prepare_build
        run: |
          IMAGE_NAME="${IMAGE_BASE_NAME}-amd64"
          DOCKER_REPO=${DOCKER_INTERMEDIATE_REPO}
          COMMIT_ID=$(git rev-parse "$GITHUB_SHA")
          IMAGE_VERSION=${COMMIT_ID:0:8}
          BUILD_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          echo "image_repo=${DOCKER_REPO}" >> $GITHUB_OUTPUT
          echo "image_name=${IMAGE_NAME}" >> $GITHUB_OUTPUT
          echo "image_full_name=${DOCKER_REPO}:${IMAGE_NAME}" >> $GITHUB_OUTPUT
          echo "image_version=${IMAGE_VERSION}" >> $GITHUB_OUTPUT
          echo "build_date=${BUILD_DATE}" >> $GITHUB_OUTPUT
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v2
      - name: Set up Docker Buildx
        id: buildx
        uses: docker/setup-buildx-action@v2
      - name: Build and load the image
        if: success()
        uses: docker/build-push-action@v3
        with:
          load: true
          build-args: |
            TAG=${{ steps.prepare_build.outputs.image_name }}
            VERSION=${{ steps.prepare_build.outputs.image_version }}
            BUILD_DATE=${{ steps.prepare_build.outputs.build_date }}
          tags: ${{ steps.prepare_build.outputs.image_full_name }}
          platforms: linux/amd64
          file: ${{env.DOCKERFILE}}
          context: .
      - name: List available tests
        id: set-matrix
        run: |
          ID=$(docker run --rm -t -d ${{ steps.prepare_build.outputs.image_full_name }} endless)
          docker exec $ID zsh -c 'cat /.exegol/build_pipeline_tests/all_commands.txt | sort -u > /.exegol/build_pipeline_tests/all_commands.sorted.txt'
          line_count=$(docker exec $ID zsh -c 'wc -l /.exegol/build_pipeline_tests/all_commands.sorted.txt | cut -d " " -f 1')
          echo "$line_count test commands found!"
          if [ $line_count -lt 1000 ]; then
            docker exec $ID zsh -c 'split -d -n 4 /.exegol/build_pipeline_tests/all_commands.sorted.txt /.exegol/build_pipeline_tests/part'
            echo "matrix_p1=$(docker exec $ID zsh -c 'head /.exegol/build_pipeline_tests/all_commands.sorted.txt -n 250' | sed '/^$/d' | perl -pe 'chomp if eof' | jq -R -s -c 'split("\n")')" >> $GITHUB_OUTPUT
            echo "matrix_p2=$(docker exec $ID zsh -c 'tail /.exegol/build_pipeline_tests/all_commands.sorted.txt -n +251 | head -n 250' | sed '/^$/d' | perl -pe 'chomp if eof' | jq -R -s -c 'split("\n")')" >> $GITHUB_OUTPUT
            echo "matrix_p3=$(docker exec $ID zsh -c 'tail /.exegol/build_pipeline_tests/all_commands.sorted.txt -n +501 | head -n 250' | sed '/^$/d' | perl -pe 'chomp if eof' | jq -R -s -c 'split("\n")')" >> $GITHUB_OUTPUT
            echo "matrix_p4=$(docker exec $ID zsh -c 'tail /.exegol/build_pipeline_tests/all_commands.sorted.txt -n +751 | head -n 250' | sed '/^$/d' | perl -pe 'chomp if eof' | jq -R -s -c 'split("\n")')" >> $GITHUB_OUTPUT
            return_code=0
          else
            echo "Too many command to test! (${line_count}/1000)"
            return_code=1
          fi
          docker stop $ID
          exit $return_code
  amd64_t1:
    needs: amd64_buildx
    if: ${{ needs.amd64_buildx.outputs.matrix_p1 != '[]' && needs.amd64_buildx.outputs.matrix_p1 != '' }}
    runs-on: [ self-hosted, test ]
    strategy:
      fail-fast: false
      matrix:
        command: ${{ fromJson(needs.amd64_buildx.outputs.matrix_p1) }}
    steps:
      - name: Image command testing
        run: |
          COMMAND=$(cat <<EOF
          ${{ matrix.command }}
          EOF
          )
          docker run --rm --env CMD="$COMMAND" ${{ env.DOCKER_INTERMEDIATE_REPO }}:${{ env.IMAGE_BASE_NAME }}-amd64 cmd zsh -c "autoload -Uz compinit; compinit; source <(grep -v oh-my-zsh.sh ~/.zshrc); eval $CMD"
  amd64_t2:
    needs: amd64_buildx
    if: ${{ needs.amd64_buildx.outputs.matrix_p2 != '[]' && needs.amd64_buildx.outputs.matrix_p2 != '' }}
    runs-on: [ self-hosted, test ]
    strategy:
      fail-fast: false
      matrix:
        command: ${{ fromJson(needs.amd64_buildx.outputs.matrix_p2) }}
    steps:
      - name: Image command testing
        run: |
          COMMAND=$(cat <<EOF
          ${{ matrix.command }}
          EOF
          )
          docker run --rm --env CMD="$COMMAND" ${{ env.DOCKER_INTERMEDIATE_REPO }}:${{ env.IMAGE_BASE_NAME }}-amd64 cmd zsh -c "autoload -Uz compinit; compinit; source <(grep -v oh-my-zsh.sh ~/.zshrc); eval $CMD"
  amd64_t3:
    needs: amd64_buildx
    if: ${{ needs.amd64_buildx.outputs.matrix_p3 != '[]' && needs.amd64_buildx.outputs.matrix_p3 != '' }}
    runs-on: [ self-hosted, test ]
    strategy:
      fail-fast: false
      matrix:
        command: ${{ fromJson(needs.amd64_buildx.outputs.matrix_p3) }}
    steps:
      - name: Image command testing
        run: |
          COMMAND=$(cat <<EOF
          ${{ matrix.command }}
          EOF
          )
          docker run --rm --env CMD="$COMMAND" ${{ env.DOCKER_INTERMEDIATE_REPO }}:${{ env.IMAGE_BASE_NAME }}-amd64 cmd zsh -c "autoload -Uz compinit; compinit; source <(grep -v oh-my-zsh.sh ~/.zshrc); eval $CMD"
  amd64_t4:
    needs: amd64_buildx
    if: ${{ needs.amd64_buildx.outputs.matrix_p4 != '[]' && needs.amd64_buildx.outputs.matrix_p4 != '' }}
    runs-on: [ self-hosted, test ]
    strategy:
      fail-fast: false
      matrix:
        command: ${{ fromJson(needs.amd64_buildx.outputs.matrix_p4) }}
    steps:
      - name: Image command testing
        run: |
          COMMAND=$(cat <<EOF
          ${{ matrix.command }}
          EOF
          )
          docker run --rm --env CMD="$COMMAND" ${{ env.DOCKER_INTERMEDIATE_REPO }}:${{ env.IMAGE_BASE_NAME }}-amd64 cmd zsh -c "autoload -Uz compinit; compinit; source <(grep -v oh-my-zsh.sh ~/.zshrc); eval $CMD"

  amd64_test_results:
    needs:
      - amd64_buildx
      - amd64_t1
      - amd64_t2
      - amd64_t3
      - amd64_t4
    runs-on: [ self-hosted, test ]
    if: always()
    steps:
      - run: |
          (${{ !contains(needs.*.result, 'failure') }} && ${{ !contains(needs.*.result, 'cancelled') }}) && (echo 'All tests were successful!' && exit 0) || (echo 'Some tests failed, the image will not be pushed'; exit 1)
  amd64_push:
    needs:
      - amd64_buildx
      - amd64_t1
      - amd64_t2
      - amd64_t3
      - amd64_t4
    runs-on: [ self-hosted, test ]
    if: ${{ always() && !contains(needs.*.result, 'failure') && !contains(needs.*.result, 'cancelled') }}
    steps:
      - name: Login to Dockerhub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
      - name: Push docker image
        run: docker push ${{ env.DOCKER_INTERMEDIATE_REPO }}:${{ env.IMAGE_BASE_NAME }}-amd64
  amd64_clean:
    needs: amd64_push
    runs-on: [ self-hosted, test ]
    if: always()  # always mode clean the environment even when the task is cancelled by a user
    steps:
      - name: Clean unused dangling images
        run: docker image prune --filter "label=org.exegol.app=Exegol" --force

  arm64_buildx:
    timeout-minutes: 360
    runs-on: [ self-hosted, arm64 ]
    outputs:
      matrix_p1: ${{ steps.set-matrix.outputs.matrix_p1 }}
      matrix_p2: ${{ steps.set-matrix.outputs.matrix_p2 }}
      matrix_p3: ${{ steps.set-matrix.outputs.matrix_p3 }}
      matrix_p4: ${{ steps.set-matrix.outputs.matrix_p4 }}
    steps:
      - name: Checkout
        uses: actions/checkout@v3
      - name: Prepare build
        id: prepare_build
        run: |
          IMAGE_NAME="${IMAGE_BASE_NAME}-arm64"
          DOCKER_REPO=${DOCKER_INTERMEDIATE_REPO}
          COMMIT_ID=$(git rev-parse "$GITHUB_SHA")
          IMAGE_VERSION=${COMMIT_ID:0:8}
          BUILD_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          echo "image_repo=${DOCKER_REPO}" >> $GITHUB_OUTPUT
          echo "image_name=${IMAGE_NAME}" >> $GITHUB_OUTPUT
          echo "image_full_name=${DOCKER_REPO}:${IMAGE_NAME}" >> $GITHUB_OUTPUT
          echo "image_version=${IMAGE_VERSION}" >> $GITHUB_OUTPUT
          echo "build_date=${BUILD_DATE}" >> $GITHUB_OUTPUT
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v2
      - name: Set up Docker Buildx
        id: buildx
        uses: docker/setup-buildx-action@v2
      - name: Build and load the image
        if: success()
        uses: docker/build-push-action@v3
        with:
          load: true
          build-args: |
            TAG=${{ steps.prepare_build.outputs.image_name }}
            VERSION=${{ steps.prepare_build.outputs.image_version }}
            BUILD_DATE=${{ steps.prepare_build.outputs.build_date }}
          tags: ${{ steps.prepare_build.outputs.image_full_name }}
          platforms: linux/arm64
          file: ${{env.DOCKERFILE}}
          context: .
      - name: List available tests
        id: set-matrix
        run: |
          ID=$(docker run --rm -t -d ${{ steps.prepare_build.outputs.image_full_name }} endless)
          docker exec $ID zsh -c 'cat /.exegol/build_pipeline_tests/all_commands.txt | sort -u > /.exegol/build_pipeline_tests/all_commands.sorted.txt'
          line_count=$(docker exec $ID zsh -c 'wc -l /.exegol/build_pipeline_tests/all_commands.sorted.txt | cut -d " " -f 1')
          echo "$line_count test commands found!"
          if [ $line_count -lt 1000 ]; then
            docker exec $ID zsh -c 'split -d -n 4 /.exegol/build_pipeline_tests/all_commands.sorted.txt /.exegol/build_pipeline_tests/part'
            echo "matrix_p1=$(docker exec $ID zsh -c 'head /.exegol/build_pipeline_tests/all_commands.sorted.txt -n 250' | sed '/^$/d' | perl -pe 'chomp if eof' | jq -R -s -c 'split("\n")')" >> $GITHUB_OUTPUT
            echo "matrix_p2=$(docker exec $ID zsh -c 'tail /.exegol/build_pipeline_tests/all_commands.sorted.txt -n +251 | head -n 250' | sed '/^$/d' | perl -pe 'chomp if eof' | jq -R -s -c 'split("\n")')" >> $GITHUB_OUTPUT
            echo "matrix_p3=$(docker exec $ID zsh -c 'tail /.exegol/build_pipeline_tests/all_commands.sorted.txt -n +501 | head -n 250' | sed '/^$/d' | perl -pe 'chomp if eof' | jq -R -s -c 'split("\n")')" >> $GITHUB_OUTPUT
            echo "matrix_p4=$(docker exec $ID zsh -c 'tail /.exegol/build_pipeline_tests/all_commands.sorted.txt -n +751 | head -n 250' | sed '/^$/d' | perl -pe 'chomp if eof' | jq -R -s -c 'split("\n")')" >> $GITHUB_OUTPUT
            return_code=0
          else
            echo "Too many command to test! (${line_count}/1000)"
            return_code=1
          fi
          docker stop $ID
          exit $return_code
  arm64_t1:
    needs: arm64_buildx
    if: ${{ needs.arm64_buildx.outputs.matrix_p1 != '[]' && needs.arm64_buildx.outputs.matrix_p1 != '' }}
    runs-on: [ self-hosted, arm64 ]
    strategy:
      fail-fast: false
      matrix:
        command: ${{ fromJson(needs.arm64_buildx.outputs.matrix_p1) }}
    steps:
      - name: Image command testing
        run: |
          COMMAND=$(cat <<EOF
          ${{ matrix.command }}
          EOF
          )
          docker run --rm --env CMD="$COMMAND" ${{ env.DOCKER_INTERMEDIATE_REPO }}:${{ env.IMAGE_BASE_NAME }}-arm64 cmd zsh -c "autoload -Uz compinit; compinit; source <(grep -v oh-my-zsh.sh ~/.zshrc); eval $CMD"
  arm64_t2:
    needs: arm64_buildx
    if: ${{ needs.arm64_buildx.outputs.matrix_p2 != '[]' && needs.arm64_buildx.outputs.matrix_p2 != '' }}
    runs-on: [ self-hosted, arm64 ]
    strategy:
      fail-fast: false
      matrix:
        command: ${{ fromJson(needs.arm64_buildx.outputs.matrix_p2) }}
    steps:
      - name: Image command testing
        run: |
          COMMAND=$(cat <<EOF
          ${{ matrix.command }}
          EOF
          )
          docker run --rm --env CMD="$COMMAND" ${{ env.DOCKER_INTERMEDIATE_REPO }}:${{ env.IMAGE_BASE_NAME }}-arm64 cmd zsh -c "autoload -Uz compinit; compinit; source <(grep -v oh-my-zsh.sh ~/.zshrc); eval $CMD"
  arm64_t3:
    needs: arm64_buildx
    if: ${{ needs.arm64_buildx.outputs.matrix_p3 != '[]' && needs.arm64_buildx.outputs.matrix_p3 != '' }}
    runs-on: [ self-hosted, arm64 ]
    strategy:
      fail-fast: false
      matrix:
        command: ${{ fromJson(needs.arm64_buildx.outputs.matrix_p3) }}
    steps:
      - name: Image command testing
        run: |
          COMMAND=$(cat <<EOF
          ${{ matrix.command }}
          EOF
          )
          docker run --rm --env CMD="$COMMAND" ${{ env.DOCKER_INTERMEDIATE_REPO }}:${{ env.IMAGE_BASE_NAME }}-arm64 cmd zsh -c "autoload -Uz compinit; compinit; source <(grep -v oh-my-zsh.sh ~/.zshrc); eval $CMD"
  arm64_t4:
    needs: arm64_buildx
    if: ${{ needs.arm64_buildx.outputs.matrix_p4 != '[]' && needs.arm64_buildx.outputs.matrix_p4 != '' }}
    runs-on: [ self-hosted, arm64 ]
    strategy:
      fail-fast: false
      matrix:
        command: ${{ fromJson(needs.arm64_buildx.outputs.matrix_p4) }}
    steps:
      - name: Image command testing
        run: |
          COMMAND=$(cat <<EOF
          ${{ matrix.command }}
          EOF
          )
          docker run --rm --env CMD="$COMMAND" ${{ env.DOCKER_INTERMEDIATE_REPO }}:${{ env.IMAGE_BASE_NAME }}-arm64 cmd zsh -c "autoload -Uz compinit; compinit; source <(grep -v oh-my-zsh.sh ~/.zshrc); eval $CMD"

  arm64_test_results:
    needs:
      - arm64_buildx
      - arm64_t1
      - arm64_t2
      - arm64_t3
      - arm64_t4
    runs-on: [ self-hosted, arm64 ]
    if: always()
    steps:
      - run: |
          (${{ !contains(needs.*.result, 'failure') }} && ${{ !contains(needs.*.result, 'cancelled') }}) && (echo 'All tests were successful!' && exit 0) || (echo 'Some tests failed, the image will not be pushed'; exit 1)
  arm64_push:
    needs:
      - arm64_buildx
      - arm64_t1
      - arm64_t2
      - arm64_t3
      - arm64_t4
    runs-on: [ self-hosted, arm64 ]
    if: ${{ always() && !contains(needs.*.result, 'failure') && !contains(needs.*.result, 'cancelled') }}
    steps:
      - name: Login to Dockerhub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
      - name: Push docker image
        run: docker push ${{ env.DOCKER_INTERMEDIATE_REPO }}:${{ env.IMAGE_BASE_NAME }}-arm64
  arm64_clean:
    needs: arm64_push
    runs-on: [ self-hosted, arm64 ]
    if: always()  # always mode clean the environment even when the task is cancelled by a user
    steps:
      - name: Clean unused dangling images
        run: docker image prune --filter "label=org.exegol.app=Exegol" --force

  manifest_build:
    timeout-minutes: 60
    needs: [arm64_push, amd64_push]
    runs-on: self-hosted
    if: ${{ always() && !contains(needs.*.result, 'failure') && !contains(needs.*.result, 'cancelled') }}
    steps:
      - name: Login to Dockerhub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
      -
        name: Create and push manifest
        if: success()
        run: |
          docker manifest create ${DOCKER_PROD_REPO}:${IMAGE_BASE_NAME} ${DOCKER_INTERMEDIATE_REPO}:${IMAGE_BASE_NAME}-arm64 ${DOCKER_INTERMEDIATE_REPO}:${IMAGE_BASE_NAME}-amd64
          docker manifest push ${DOCKER_PROD_REPO}:${IMAGE_BASE_NAME}
          docker manifest rm ${DOCKER_PROD_REPO}:${IMAGE_BASE_NAME}
      -
        name: Remove intermediate images
        run: |
          HUB_TOKEN=$(curl -s -H "Content-Type: application/json" -X POST -d "{\"username\": \"${{ secrets.DOCKER_USERNAME }}\", \"password\": \"${{ secrets.DOCKER_PASSWORD }}\"}" https://hub.docker.com/v2/users/login/ | jq -r .token)
          curl -i -X DELETE -H "Accept: application/json" -H "Authorization: JWT $HUB_TOKEN" https://hub.docker.com/v2/repositories/${DOCKER_INTERMEDIATE_REPO}/tags/${IMAGE_BASE_NAME}-arm64/
          curl -i -X DELETE -H "Accept: application/json" -H "Authorization: JWT $HUB_TOKEN" https://hub.docker.com/v2/repositories/${DOCKER_INTERMEDIATE_REPO}/tags/${IMAGE_BASE_NAME}-amd64/
