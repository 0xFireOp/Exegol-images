on:
  workflow_call:
    inputs:
      DOCKER_BUILD_REPO:
        required: true
        type: string
      DOCKER_TARGET_REPO:
        required: false
        default: ''
        type: string
      IMAGE_BASE_NAME:
        required: true
        type: string
      IMAGE_VERSION:
        required: false
        default: ''
        type: string
      DOCKERFILE:
        required: true
        type: string
      SUPPORTED_ARCH:
        required: true
        type: string
    secrets:
      DOCKER_PASSWORD:
        required: true
      DOCKER_USERNAME:
        required: true

jobs:
  build:
    name: Build
    strategy:
      fail-fast: false
      matrix:
        arch: ${{ fromJson(inputs.SUPPORTED_ARCH) }}
    uses: ./.github/workflows/sub_build.yml
    with:
      DOCKER_BUILD_REPO: ${{ inputs.DOCKER_BUILD_REPO }}
      IMAGE_BASE_NAME: ${{ inputs.IMAGE_BASE_NAME }}
      IMAGE_VERSION: ${{ inputs.IMAGE_VERSION }}
      DOCKERFILE: ${{ inputs.DOCKERFILE }}
      ARCH: ${{ matrix.arch }}
#  pre_test:
#    name: Pre-test
#    needs: build
#    strategy:
#      matrix:
#        arch: ${{ fromJson(inputs.SUPPORTED_ARCH) }}
#    runs-on:
#      - self-hosted
#      - builder
#      - ${{ matrix.arch }}
#    steps:
#      - name: Read tests from image
#        id: prepare
#        run: |
#          ID=$(docker run --rm -t -d ${{ inputs.DOCKER_BUILD_REPO }}:${{ inputs.IMAGE_BASE_NAME }}-${{ matrix.arch }} endless)
#          docker exec $ID zsh -c 'cat /.exegol/build_pipeline_tests/all_commands.txt | grep -vE "^\s*$" | sort -u > /.exegol/build_pipeline_tests/all_commands.sorted.txt'
#          line_count=$(docker exec $ID zsh -c 'wc -l /.exegol/build_pipeline_tests/all_commands.sorted.txt | cut -d " " -f 1')
#          echo "$line_count test commands found!"
#          docker exec $ID python3 /.exegol/build_pipeline_tests/ingest_tests.py
#          docker exec $ID zsh -c 'cat /.exegol/build_pipeline_tests/tests.json'
#          echo "matrix_tests=$(docker exec $ID zsh -c 'cat /.exegol/build_pipeline_tests/tests.json')" >> $GITHUB_OUTPUT
#          docker stop $ID
#    outputs:
#      matrix_tests: ${{ steps.prepare.outputs.matrix_tests }}
#      # todo : save an output for each arch. In it's current state, the matrix_tests is overwritten by the last
#      # execution of "prepare". So for example, if there are amd64 tests, that don't have the arm64 equivalent (because
#      # tool install isn't supported), then the test will not be made for amd64 if arm64 was the last runner to execute,
#      # and arm64 is last in the inputs.SUPPORTED_ARCH order
#  test:
#    name: Test
#    needs:
#      - build
#      - pre_test
#    if: ${{ always() && needs.build.result == 'success' }}
#    strategy:
#      fail-fast: false
#      matrix:
#        arch: ${{ fromJson(inputs.SUPPORTED_ARCH) }}
#        # list of lists. Each sublist is made of up to 250 commands (max for one workflow)
#        # each sublist will be iterated into in the sub_test_batch.yml workflow
#        batch_of_250: ${{ fromJson(needs.pre_test.outputs.matrix_tests) }}
#    uses: ./.github/workflows/sub_test_batch.yml
#    with:
#      DOCKER_BUILD_REPO: ${{ inputs.DOCKER_BUILD_REPO }}
#      IMAGE_BASE_NAME: ${{ inputs.IMAGE_BASE_NAME }}
#      ARCH: ${{ matrix.arch }}
#      TESTS: ${{ matrix.batch_of_250 }}
  pre_test_amd64:
    name: Pre-test AMD64
    needs: build
    runs-on:
      - self-hosted
      - builder
      - amd64
    steps:
      - name: Read tests from amd64 image
        id: prepare
        run: |
          ID=$(docker run --rm -t -d ${{ inputs.DOCKER_BUILD_REPO }}:${{ inputs.IMAGE_BASE_NAME }}-amd64 endless)
          docker exec $ID zsh -c 'cat /.exegol/build_pipeline_tests/all_commands.txt | grep -vE "^\s*$" | sort -u > /.exegol/build_pipeline_tests/all_commands.sorted.txt'
          line_count=$(docker exec $ID zsh -c 'wc -l /.exegol/build_pipeline_tests/all_commands.sorted.txt | cut -d " " -f 1')
          echo "$line_count test commands found!"
          docker exec $ID python3 /.exegol/build_pipeline_tests/ingest_tests.py
          docker exec $ID zsh -c 'cat /.exegol/build_pipeline_tests/tests.json'
          echo "matrix_tests=$(docker exec $ID zsh -c 'cat /.exegol/build_pipeline_tests/tests.json')" >> $GITHUB_OUTPUT
          docker stop $ID
    outputs:
      matrix_tests_amd64: ${{ steps.prepare.outputs.matrix_tests }}
  pre_test_arm64:
    name: Pre-test ARM64
    needs: build
    runs-on:
      - self-hosted
      - builder
      - arm64
    steps:
      - name: Read tests from image
        id: prepare
        run: |
          ID=$(docker run --rm -t -d ${{ inputs.DOCKER_BUILD_REPO }}:${{ inputs.IMAGE_BASE_NAME }}-arm64 endless)
          docker exec $ID zsh -c 'cat /.exegol/build_pipeline_tests/all_commands.txt | grep -vE "^\s*$" | sort -u > /.exegol/build_pipeline_tests/all_commands.sorted.txt'
          line_count=$(docker exec $ID zsh -c 'wc -l /.exegol/build_pipeline_tests/all_commands.sorted.txt | cut -d " " -f 1')
          echo "$line_count test commands found!"
          docker exec $ID python3 /.exegol/build_pipeline_tests/ingest_tests.py
          docker exec $ID zsh -c 'cat /.exegol/build_pipeline_tests/tests.json'
          echo "matrix_tests=$(docker exec $ID zsh -c 'cat /.exegol/build_pipeline_tests/tests.json')" >> $GITHUB_OUTPUT
          docker stop $ID
    outputs:
      matrix_tests_arm64: ${{ steps.prepare.outputs.matrix_tests }}
  test_amd64:
    name: Test AMD64
    needs:
      - build
      - pre_test_amd64
    if: ${{ always() && needs.build.result == 'success' }}
    strategy:
      fail-fast: false
      matrix:
        # list of lists. Each sublist is made of up to 250 commands (max for one workflow)
        # each sublist will be iterated into in the sub_test_batch.yml workflow
        batch_of_250: ${{ fromJson(needs.pre_test_amd64.outputs.matrix_tests_amd64) }}
#        batch_of_250: ${{ fromJson(needs.pre_test.outputs.matrix_tests_amd64) }}
    uses: ./.github/workflows/sub_test_batch.yml
    with:
      DOCKER_BUILD_REPO: ${{ inputs.DOCKER_BUILD_REPO }}
      IMAGE_BASE_NAME: ${{ inputs.IMAGE_BASE_NAME }}
      ARCH: "amd64"
      TESTS: ${{ matrix.batch_of_250 }}
  test_arm64:
    name: Test ARM64
    needs:
      - build
      - pre_test_arm64
    if: ${{ always() && needs.build.result == 'success' }}
    strategy:
      fail-fast: false
      matrix:
        # list of lists. Each sublist is made of up to 250 commands (max for one workflow)
        # each sublist will be iterated into in the sub_test_batch.yml workflow
        batch_of_250: ${{ fromJson(needs.pre_test_arm64.outputs.matrix_tests_arm64) }}
#        batch_of_250: ${{ fromJson(needs.pre_test.outputs.matrix_tests_arm64) }}
    uses: ./.github/workflows/sub_test_batch.yml
    with:
      DOCKER_BUILD_REPO: ${{ inputs.DOCKER_BUILD_REPO }}
      IMAGE_BASE_NAME: ${{ inputs.IMAGE_BASE_NAME }}
      ARCH: "arm64"
      TESTS: ${{ matrix.batch_of_250 }}
# Testing nested testing for contextualized matrixes
# commented while issue: https://github.com/actions/runner/issues/2424
# will replace pre_test_amd64/arm64 and test_amd64/arm64
#  test:
#    name: Test
#    needs: build
#    strategy:
#      fail-fast: false
#      matrix:
#        arch: ${{ fromJson(inputs.SUPPORTED_ARCH) }}
#    uses: ./.github/workflows/sub_test.yml
#    with:
#      DOCKER_BUILD_REPO: ${{ inputs.DOCKER_BUILD_REPO }}
#      IMAGE_BASE_NAME: ${{ inputs.IMAGE_BASE_NAME }}
#      ARCH: ${{ matrix.arch }}
  push:
    # todo: make sure to remove even if not pushed? or will it be removed with clean_runners_1 ?
    name: Push
    needs:
#      - test
      - test_amd64
      - test_arm64
    if: ${{ always() && needs.*.result == 'success' }}
#    if: ${{ always() && needs.test.result == 'success' }}
    strategy:
      fail-fast: false
      matrix:
        arch: ${{ fromJson(inputs.SUPPORTED_ARCH) }}
    uses: ./.github/workflows/sub_push.yml
    with:
      DOCKER_BUILD_REPO: ${{ inputs.DOCKER_BUILD_REPO }}
      IMAGE_BASE_NAME: ${{ inputs.IMAGE_BASE_NAME }}
      DOCKERFILE: ${{ inputs.DOCKERFILE }}
      ARCH: ${{ matrix.arch }}
    secrets: inherit
  publish:
    name: Publish
    timeout-minutes: 60
    needs:
      - push
    runs-on: self-hosted
    if: ${{ always() && !contains(needs.*.result, 'failure') && !contains(needs.*.result, 'cancelled') && inputs.DOCKER_TARGET_REPO != '' }}
    env:
      DOCKER_BUILD_REPO: ${{ inputs.DOCKER_BUILD_REPO }}
      DOCKER_TARGET_REPO: ${{ inputs.DOCKER_TARGET_REPO }}
      IMAGE_BASE_NAME: ${{ inputs.IMAGE_BASE_NAME }}
      IMAGE_VERSION: ${{ inputs.IMAGE_VERSION }}
    steps:
      - name: Login to Dockerhub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
      - name: Create and push manifest
        if: success()
        run: |
          echo "Create manifest"
          docker manifest create ${DOCKER_TARGET_REPO}:${IMAGE_BASE_NAME} ${DOCKER_BUILD_REPO}:${IMAGE_BASE_NAME}-arm64 ${DOCKER_BUILD_REPO}:${IMAGE_BASE_NAME}-amd64
          docker manifest push ${DOCKER_TARGET_REPO}:${IMAGE_BASE_NAME}
          docker manifest rm ${DOCKER_TARGET_REPO}:${IMAGE_BASE_NAME}
      - name: Create and push version manifest
        if: success() && inputs.IMAGE_VERSION != ''
        run: |
          echo "Create version manifest"
          docker manifest create ${DOCKER_TARGET_REPO}:${IMAGE_BASE_NAME}-${IMAGE_VERSION} ${DOCKER_BUILD_REPO}:${IMAGE_BASE_NAME}-arm64 ${DOCKER_BUILD_REPO}:${IMAGE_BASE_NAME}-amd64
          docker manifest push ${DOCKER_TARGET_REPO}:${IMAGE_BASE_NAME}-${IMAGE_VERSION}
          docker manifest rm ${DOCKER_TARGET_REPO}:${IMAGE_BASE_NAME}-${IMAGE_VERSION}


  clean_runners_1:
    name: Clean runners
    needs:
      - build
      - push
#      - test
      - test_amd64
      - test_arm64
    if: always()
    strategy:
      matrix:
        arch: ${{ fromJson(inputs.SUPPORTED_ARCH) }}
    runs-on:
      - self-hosted
      - builder
      - ${{ matrix.arch }}
    steps:
      - name: Clean unused dangling images
        run: docker image prune --filter "label=org.exegol.app=Exegol" --force
      - name: Clean unused volumes
        run: docker volume prune --force
  clean_runners_2:
    name: Remove built images
    needs:
      - build
      - push
#      - test
      - test_amd64
      - test_arm64
    if: ${{ always() && needs.build.result == 'success' && needs.push.result == 'success' }}
    strategy:
      matrix:
        arch: ${{ fromJson(inputs.SUPPORTED_ARCH) }}
    runs-on:
      - self-hosted
      - builder
      - ${{ matrix.arch }}
    steps:
      - name: Remove build image ${{ inputs.IMAGE_BASE_NAME }}-${{ matrix.arch }}
        run: |
          image_name=${{ inputs.DOCKER_BUILD_REPO }}:${{ inputs.IMAGE_BASE_NAME }}-${{ matrix.ARCH }}
          echo "Removing $image_name"
          docker image inspect $image_name && docker rmi $image_name
  clean_registry:
    name: Cleaning registry
    timeout-minutes: 60
    needs:
      - publish
    runs-on: self-hosted
    if: ${{ always() && !contains(needs.*.result, 'failure') && !contains(needs.*.result, 'cancelled') }}
    env:
      DOCKER_BUILD_REPO: ${{ inputs.DOCKER_BUILD_REPO }}
      IMAGE_BASE_NAME: ${{ inputs.IMAGE_BASE_NAME }}
    steps:
      - name: Remove arch-specific images on intermediate registry
        run: |
          HUB_TOKEN=$(curl -s -H "Content-Type: application/json" -X POST -d "{\"username\": \"${{ secrets.DOCKER_USERNAME }}\", \"password\": \"${{ secrets.DOCKER_PASSWORD }}\"}" https://hub.docker.com/v2/users/login/ | jq -r .token)
          curl -i -X DELETE -H "Accept: application/json" -H "Authorization: JWT $HUB_TOKEN" https://hub.docker.com/v2/repositories/${DOCKER_BUILD_REPO}/tags/${IMAGE_BASE_NAME}-arm64/
          curl -i -X DELETE -H "Accept: application/json" -H "Authorization: JWT $HUB_TOKEN" https://hub.docker.com/v2/repositories/${DOCKER_BUILD_REPO}/tags/${IMAGE_BASE_NAME}-amd64/
