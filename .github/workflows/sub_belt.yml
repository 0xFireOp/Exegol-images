name: Belt

on:
  workflow_call:
    inputs:
      DOCKER_BUILD_REPO:
        required: true
        type: string
      DOCKER_TARGET_REPO:
        required: false
        default: ''
        type: string
      IMAGE_BASE_NAME:
        required: true
        type: string
      IMAGE_VERSION:
        required: false
        default: ''
        type: string
      DOCKERFILE:
        required: true
        type: string
      SUPPORTED_ARCH:
        required: true
        type: string
    secrets:
      DOCKER_PASSWORD:
        required: true
      DOCKER_USERNAME:
        required: true

jobs:
  build:
    name: Build
    strategy:
      matrix:
        arch: ${{ fromJson(inputs.SUPPORTED_ARCH) }}
    uses: ./.github/workflows/sub_build.yml
    with:
      DOCKER_BUILD_REPO: ${{ inputs.DOCKER_BUILD_REPO }}
      IMAGE_BASE_NAME: ${{ inputs.IMAGE_BASE_NAME }}
      IMAGE_VERSION: ${{ inputs.IMAGE_VERSION }}
      DOCKERFILE: ${{ inputs.DOCKERFILE }}
      ARCH: ${{ matrix.arch }}
  pre_test:
    name: Pre-test
    needs: build
    strategy:
      matrix:
        arch: ${{ fromJson(inputs.SUPPORTED_ARCH) }}
    runs-on:
      - self-hosted
      - builder
      - ${{ matrix.arch }}
    steps:
      - name: Read tests from image
        id: prepare
        run: |
          ID=$(docker run --rm -t -d ${{ inputs.DOCKER_BUILD_REPO }}:${{ inputs.IMAGE_BASE_NAME }}-${{ matrix.arch }} endless)
          docker exec $ID zsh -c 'cat /.exegol/build_pipeline_tests/all_commands.txt | grep -vE "^\s*$" | sort -u > /.exegol/build_pipeline_tests/all_commands.sorted.txt'
          line_count=$(docker exec $ID zsh -c 'wc -l /.exegol/build_pipeline_tests/all_commands.sorted.txt | cut -d " " -f 1')
          echo "$line_count test commands found!"
          docker exec $ID python3 /.exegol/build_pipeline_tests/ingest_tests.py
          docker exec $ID zsh -c 'cat /.exegol/build_pipeline_tests/tests.json'
          echo "matrix_tests=$(docker exec $ID zsh -c 'cat /.exegol/build_pipeline_tests/tests.json')" >> $GITHUB_OUTPUT
          if [ $line_count -lt 1000 ]; then
            echo "matrix_p1=$(docker exec $ID zsh -c 'head /.exegol/build_pipeline_tests/all_commands.sorted.txt -n 250' | jq -R -s -c 'split("\n")')" >> $GITHUB_OUTPUT
            echo "matrix_p2=$(docker exec $ID zsh -c 'tail /.exegol/build_pipeline_tests/all_commands.sorted.txt -n +251 | head -n 250' | jq -R -s -c 'split("\n")')" >> $GITHUB_OUTPUT
            echo "matrix_p3=$(docker exec $ID zsh -c 'tail /.exegol/build_pipeline_tests/all_commands.sorted.txt -n +501 | head -n 250' | jq -R -s -c 'split("\n")')" >> $GITHUB_OUTPUT
            echo "matrix_p4=$(docker exec $ID zsh -c 'tail /.exegol/build_pipeline_tests/all_commands.sorted.txt -n +751 | head -n 250' | jq -R -s -c 'split("\n")')" >> $GITHUB_OUTPUT
            return_code=0
          else
            echo "Too many command to test! (${line_count}/1000)"
            echo "Maximum of 250 tests per matrix."
            return_code=1
          fi
          docker stop $ID
          exit $return_code
    outputs:
      matrix_tests: ${{ steps.prepare.outputs.matrix_tests }}
      # todo : save an output for each arch
  test:
    name: Test
    needs:
      - build
      - pre_test
    if: ${{ always() && needs.build.result == 'success' }}
    strategy:
      fail-fast: false
      matrix:
        arch: ${{ fromJson(inputs.SUPPORTED_ARCH) }}
        batch: ${{ fromJson(needs.pre_test.outputs.matrix_tests).${{ matrix.arch }} }}
    uses: ./.github/workflows/sub_test.yml
    with:
      DOCKER_BUILD_REPO: ${{ inputs.DOCKER_BUILD_REPO }}
      IMAGE_BASE_NAME: ${{ inputs.IMAGE_BASE_NAME }}
      ARCH: ${{ matrix.arch }}
      TESTS: ${{ matrix.batch }}
  push:
    # todo: make sure to remove even if not pushed? or will it be removed with clean_runners_1 ?
    name: Push
    needs:
      - test
    if: ${{ always() && needs.test.result == 'success' }}
    strategy:
      fail-fast: false
      matrix:
        arch: ${{ fromJson(inputs.SUPPORTED_ARCH) }}
    uses: ./.github/workflows/sub_push.yml
    with:
      DOCKER_BUILD_REPO: ${{ inputs.DOCKER_BUILD_REPO }}
      IMAGE_BASE_NAME: ${{ inputs.IMAGE_BASE_NAME }}
      DOCKERFILE: ${{ inputs.DOCKERFILE }}
      ARCH: ${{ matrix.arch }}
    secrets: inherit
  publish:
    name: Publish
    timeout-minutes: 60
    needs:
      - push
    runs-on: self-hosted
    if: ${{ always() && !contains(needs.*.result, 'failure') && !contains(needs.*.result, 'cancelled') && inputs.DOCKER_TARGET_REPO != '' }}
    env:
      DOCKER_BUILD_REPO: ${{ inputs.DOCKER_BUILD_REPO }}
      DOCKER_TARGET_REPO: ${{ inputs.DOCKER_TARGET_REPO }}
      IMAGE_BASE_NAME: ${{ inputs.IMAGE_BASE_NAME }}
      IMAGE_VERSION: ${{ inputs.IMAGE_VERSION }}
    steps:
      - name: Login to Dockerhub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
      - name: Create and push manifest
        if: success()
        run: |
          echo "Create manifest"
          docker manifest create ${DOCKER_TARGET_REPO}:${IMAGE_BASE_NAME} ${DOCKER_BUILD_REPO}:${IMAGE_BASE_NAME}-arm64 ${DOCKER_BUILD_REPO}:${IMAGE_BASE_NAME}-amd64
          docker manifest push ${DOCKER_TARGET_REPO}:${IMAGE_BASE_NAME}
          docker manifest rm ${DOCKER_TARGET_REPO}:${IMAGE_BASE_NAME}
      - name: Create and push version manifest
        if: success() && inputs.IMAGE_VERSION != ''
        run: |
          echo "Create version manifest"
          docker manifest create ${DOCKER_TARGET_REPO}:${IMAGE_BASE_NAME}-${IMAGE_VERSION} ${DOCKER_BUILD_REPO}:${IMAGE_BASE_NAME}-arm64 ${DOCKER_BUILD_REPO}:${IMAGE_BASE_NAME}-amd64
          docker manifest push ${DOCKER_TARGET_REPO}:${IMAGE_BASE_NAME}-${IMAGE_VERSION}
          docker manifest rm ${DOCKER_TARGET_REPO}:${IMAGE_BASE_NAME}-${IMAGE_VERSION}


  clean_runners_1:
    name: Clean runners
    needs:
      - build
      - push
      - test
    if: always()
    strategy:
      matrix:
        arch: ${{ fromJson(inputs.SUPPORTED_ARCH) }}
    runs-on:
      - self-hosted
      - builder
      - ${{ matrix.arch }}
    steps:
      - name: Clean unused dangling images
        run: docker image prune --filter "label=org.exegol.app=Exegol" --force
      - name: Clean unused volumes
        run: docker volume prune --force
  clean_runners_2:
    name: Remove built images
    needs:
      - build
      - push
      - test
    if: ${{ always() && needs.build.result == 'success' && needs.push.result == 'success' }}
    strategy:
      matrix:
        arch: ${{ fromJson(inputs.SUPPORTED_ARCH) }}
    runs-on:
      - self-hosted
      - builder
      - ${{ matrix.arch }}
    steps:
      - name: Remove build image ${{ inputs.IMAGE_BASE_NAME }}-${{ matrix.arch }}
        run: |
          image_name=${{ inputs.DOCKER_BUILD_REPO }}:${{ inputs.IMAGE_BASE_NAME }}-${{ matrix.ARCH }}
          echo "Removing $image_name"
          docker image inspect $image_name && docker rmi $image_name
    

  clean_registry:
    name: Cleaning registry
    timeout-minutes: 60
    needs:
      - publish
    runs-on: self-hosted
    if: ${{ always() && !contains(needs.*.result, 'failure') && !contains(needs.*.result, 'cancelled') }}
    env:
      DOCKER_BUILD_REPO: ${{ inputs.DOCKER_BUILD_REPO }}
      IMAGE_BASE_NAME: ${{ inputs.IMAGE_BASE_NAME }}
    steps:
      - name: Remove arch-specific images on intermediate registry
        run: |
          HUB_TOKEN=$(curl -s -H "Content-Type: application/json" -X POST -d "{\"username\": \"${{ secrets.DOCKER_USERNAME }}\", \"password\": \"${{ secrets.DOCKER_PASSWORD }}\"}" https://hub.docker.com/v2/users/login/ | jq -r .token)
          curl -i -X DELETE -H "Accept: application/json" -H "Authorization: JWT $HUB_TOKEN" https://hub.docker.com/v2/repositories/${DOCKER_BUILD_REPO}/tags/${IMAGE_BASE_NAME}-arm64/
          curl -i -X DELETE -H "Accept: application/json" -H "Authorization: JWT $HUB_TOKEN" https://hub.docker.com/v2/repositories/${DOCKER_BUILD_REPO}/tags/${IMAGE_BASE_NAME}-amd64/
